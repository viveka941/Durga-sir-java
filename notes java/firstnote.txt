----------------------Identifire-> 
A name in java programme is called idintifire which can use for idintifcation purpose it can be method or variable name ,class name,or labal name

  1.the only allow charactrue in java Identifire are a  to z, A to Z , 0 to 9, $, _ 
  ex. total_number✅ 
    tatol#❌
    123total❌ 
  2.if are using any other charactrue we will get compile time error 
  3.Identifire is con't start number
  4.java Identifire is case sensitive language
  java language is treated case senitive  language
  int number = 10;
  int Number = 10;
  5.there is no length limit for java identifire but its not recommended to take too lengthy identifires
  6.we con't use reserved  words whats identifire
  int x =10;
  int if = 20;❌ // if is keyword

  7.all predefind java class or interface name we can use as identifires even though it is valid but it's not good programming pratice bacause it reducesd readbilites
  int String = 888; ✅ 
  int Runable = 999; ✅ 
  System.out.println(String); ✅ 
  System.out.println(Runable); ✅ 

  total_number✅
  tatol# ❌ 
  123tatol ❌ 
  ca$h ✅
  _$_$_$_$_$_$_$_$ ✅
  all@hands ❌ 
  java2share✅
  Integer✅
  Int✅
  int ❌ 

2.Reserved Word -> in java some words are reserved to represent some meaning or functionality such types of words are called reserved words
  how many reserved in java -> 53
  1.  keyword(it is have some functionality)-> (50) 
    1.Used keyword(48) -> if, else, 
      ->keyword for data types-> byes,short,char,int,long,float,double,long 
      ->flow control keyword -> if ,else, switch, case, default, do ,while, for, break, contiune,reutn
      ->Modifire keyword ->public , private,static,final, abstarct, synchronized, native, volatile,
      trasient
      ->key exception Handling-> try,catch,finally,thorw,thorws, assert,
      ->Class releated keyword-> class, inteface, extends, impliments, package, import
      -> Object releated keyword -> new instanceof, super, this
      -> return types keyword -> void 
      in java return types is mandetaory if method want any things than we have to declear that void return types
      but c language return types optional and defualt return int 
    2.Unused keyword(2)-> goto, const
    used of goto create several problem in old language hence some people banned in java 
    -> used final instedof const 
    note:- goto const or Unused keyword and if tryping to used we will compile time error 
  2.  Reserved Literals(only have values)-> (3)true,  false,null
  null-> default values of Object reference

  Enum-> we can used enum define a group named constent 
  ex. enum Month{
    jan,feb,....dec;
  }

  Consulusion
1.acl 53 reserved in java constain only lower case whenever we are compile a java programme for every class prsent in program a seperat .class file will be genereted 
alphabet symbols
2.in java we have only new keyword and no delete keywe
 beacsue disteraction uselees object responsbilitye of garbeg colletcor
3. strictfp, assert, enum these keyword new in java 
 


variable 
1.in java every variable and very exprsion has some types 
each  and every data types is clearly defined 
every assigenment should be check by compiler for type compatblili beacsue above resion we can cal consuld storngly types programming language 

java pure object oriented programming language?
java is not pure whay
more primitive data types

1.java is not consider pure object oriten programming language beacsue several oops featrue are not satisfied java (like->operator overloading , multipule inheritance).
2.moreover we are depeding on primitive data types which are non objects .

primitive data types -> 8 types
1.Numeric data type
  Integeral data types
      byte ,short , int , long
  floating point data types
     float , double
2.NonNumeric data types
     char, boolean, 

except boolean and char remains data types consider as sinned data types because we can reprsent both positive and negative numbers 


size->
  byte -> 1 byte ( 8bits )
  MAX_VALUES -> +127
  MIN_VALUES -> -128
  rangr: -128 to 127;

the most significant bit access assign bit
0 = positive number ->its reprsented directlly in a memory 
1= negative number -> its represent is tow complex form

ex->
   byte b= 10; ✅
   byte b = 127;✅
   byte b = 128;❌
   byte b = 10.5;❌
   byte b = true; ❌
   byte b = "Durga";❌

   byte is best choice if want you handling data in turms of string either form the file or network within breacket file support from network support byte.


SHORT ->(2byte(16bits))  short is very most reilly used data type  in java -32768 to 30768  is 


note :char -> 2byte

 null is object reference we con't apply primitive  if you are trying to apply than it is compile time error 


 Literals-> a constent values which can assingd variable it called variable Literals ex int x(variable name) = 10(constent value /Literals); 

   int s = 0786;❌
    int x=0777;✅
    int x1=0XBeef;✅
    int x2 = 0XBeer;❌
    int x3 = 0Xface;✅

    int x=10;✅
    long l  = 10l;✅
    int x =10l; ❌ possible loss percisions
    long l =10;✅

    byte b =10;
    byte b = 127;
    byte b 128;❌
  
    flaot f = 123.567 ; ❌
    flaot f = 123.456f ;
    double f = 123.456;
    double f 123.4567D; 
    flaot f  = 123.456d; ❌ 

    double d = 0786; ❌ ce: integer number too large
    double d =0XFace; 
    double d = 0786.0;
    double d =0Xface.0❌ 
    double d = 0777; 
    we car assing Integeral Literals directlly to flaoting point variable under the integer Literals can be specified either in decimal or octal or hexadecimal

    we can't assign flaoting point Literals to Integeral type 
    double =10;
    int x =10.0;❌ loss of percisions

    double d = 1.2e3 etri (1200)
    flaot d =1.2e3 ; ❌ 
    flaot f = 1.2e3f; 

    we can specified even in exponcial notion 
    1.2e3 = 1.2 * 10^3
            1.2*1000
            1200

    boolean Literals-> True || false
        only allowd values true or false 
        boolean b = true; 
        boolean b = 0; ❌  incompatible type : int require :boolean
        boolean b = True; ❌ con't not find symbols
        boolean b = "true" ; ❌  con't not find symbols

    Ex->
        int x=0;
        if(x) { ❌incompatible : types found : int require boolean
          sout("hello");
        }else{
          sout("hi);
        }


    char ->
    we can specified as singal charactrue within singal cottesion

    char ch = 'a';
    char ch = a ; ❌ con't find symbols : variable a 
    char ch = "a"; ❌  incompatible type found a STring require char
    char  ch = 'ab' ❌  ce: unclosed charactrue Literals, not a statement
    char ch = 97;
    sout(ch) // output a   
    
    we can specified char Literals or integeral Literals which reprsent unicode values of charactrue and that integeral Literals can be specified int decimal octaldecial allow range to 0 to 65535;
    char ch = 0XFace;
    char ch =0777;
    char ch = 65535;
    char ch = 65536;❌   ec: possible percisions loss 

    char ch = '\u0061'; // output:  a
    we can represent char Literals in unicode representation which in nothing but backslash u xxxx for digit hexadecimal number 

    illegal escape charactrue (types: 8)
    char ch = '\n' ;  // new line
    char m = '\t';   // horizental tab
    char ch = '\m'; mute char 
    char ch = '\r'; carrgiage return 
    char b = '\b'; back space
    char f = '\f'; form feed
    char ch = '\; singale quote
    char ch = "\"; double quote
    char ch = \\; backslash file path in use  


    every escape charactrue is valid char Literals ex-above

    String literals -> any sequence charactrue within double quote 
                      writen is String literals
      1.Binary literals-> for integeral data


     double d = 1__2__3_5_5; // only readbilites we can used uderscore
    System.out.println(d);
    //output->12355.0
     double d = 1__2__3_5_5.4456;
    System.out.println(d); // output-> 12355.4456
     double d = 1__2__3_5_;  ❌ // we con't used underscore in last
    System.out.println(d);

byte -> shotr
            \
                int -> long -> flaot -> double
            /
       char     

       flaot  f = 10l;
       sout(f); output 10;

    
Introduction
Array Declaration
Array Creation
Array Initialization
Array Declaration , creation 
Anonymous Arrays
Array Element
Array variable assigenment


1.
Introduction-> 
Array-> multipule values same types not to be need maultipale variable we can declear with singal memory
defination -> An Array is index collection fiexd no of homoginious data Element 
-> the main advantage we can represent huge no of values using singal variable so that readbilites of the improvd . but the main Disadvantage of array is fixed in size that is once we carete an array there is no change of incrse or decrease size base on our requirement hance to used array concept compulsary in size in advace, which may not possible always

Disadvantage ->
1.Array are fixed in memory
2.Array can hold homoginious 

One dimensinal declaration->
int []x;✅
int x[];✅
int[] x;✅

int [][] x;
int[][] x;
int x[][];
int[] x[];
int []x[];

Array Creation ->
int [] a = new int[4];
Every array in java is an Object only hence we can create array by using new Operator 

for evey array types crrosponding class are aviable and these class of part of java language and not aviable to the programmer level  
=>Sout(x.getClass().getName()) // out[[i two D aaray 

Array types       Corressponding class name
int []      -> [I
int [][]    -> [[I
double []   -> [D
shrot[] -> [S
byte[] -> [B
boolean [] -> [Z


if the time of array creation comparsalry you should specified size otherwise we will get error
int [] x = new int[];❌
int [] x= new int[6];✅
int [] x = new int[0];✅

if trying to specified array size negative int values than we will get runtime exception saying negativeArraySizeException
int [] x = new int[-4];❌

int [] x = new int[10];
int [] x = new int['a'];✅
byte b  = 20;
int [] x = new int[b];✅
int []x = new int[10L];❌

to specified array size to allowed data types are byte short char int if you are trying to specified any other types than will get compile time error 

int []x = new int[2147483647];✅

int []x = new int[2147483648];❌//CE: Integer number too large 

2D Array  = Matrix (Group of row and column)
2D array creation -> in java 2D array not implimented by using matrix style some people flowlled array of array approach multipuldimesional array creation the main advantage approach is memory utilization imporoved 

int [][][] x = new [2][][];
x[0]= int[2];
x[0][0]= new int[1];
x[0][1]=new int[2];
x[0][2]=new int[3];
x[1]=new int[2][2];

diagame=arr is =  |0|1|
              0=[0|1|2] , 1=[0|1]

which one is true
int[] a = new int[];❌
int[] a = new int[3];✅
int[][] a = new int[][];❌
int[][] a = new int[3][];✅
int[][] a = new int[][4];❌
int[][] a = new int[3][4];✅
int[][][] a = new int[3][4][5];✅
int[][][] a = new int[3][4][];✅
[][][] a = new int[3][][5];❌
int[][][] a = new int[][4][5];❌

Array Initialization
one we carete array every array Element by defualts initializer with default values
example-> 
1.int [] x =new int[3];
          sout(x) // [I@3w2
          sout(x[0]) // 0

note->whenever trying to print any reference variable internaly toString methoed will called which is implimented by default to return the String in the fowlling form ->className@hashCode_in_hexadecimalform

2.int [][] x= new int[2][3];  
            [0|1]
            [0|0|0] ,[0|0|0]
  sout(x); [[I@je23
  sout(x[0]); //[I@19238f
  sout(x[0][0]); //0

3. int [][] x = new int[2][];
                [null|null]
                [   ] // not to be decleare
   sout(x);//[[I@12
   sout(x[0]);//null
   sout(x[0][0]); /RE:nullPointException

note-> if you are trying perforem any operation null  then we will get runtime exception: nullPointException

once we create an array every element by defualt initializer with defaults values if we are not satisifed defualt values then we car override values 
with our costomized values
int []x= new int[5];
        [0|0|0|0|0]
int x[0]=10;
int [1] =1;
int [2] =2;
int [3] =3;
int [4] =4;
int [6]=70; RE:ArrayIndexOutOfBoundsSystem
int [-6]=80; RE:ArrayIndexOutOfBoundsSystem

Array Declaration Creation and Initialization in a single line ->
int [] x;
x = new int[3];
x[0]=10;
x[1]=20;
x[2]=30;

int[] x = {10,20,30};
char[] ch = {'a','e','i','o'};
String[] a = {"AB","bd","bds","ds"};

2.                [1|2]
            [10|20],[30|40|60]
  int [][]x={{10,20},{30,40,50}};

3.  int[][][] x ={{{10,20,30},{40,50,60}},
                {{70,80},90,100,110}}
                             [0|1]
                   [0|1],              [0|1]
           [10|20|30],[40,50,60]  [70|80],[90|100|110]
sout(x[0][1][2])=60
sout(x[1][0][1])=80
sout(x[1][0][0])=70
sout(x[2][0][0])=RE:ArrayIndexOutOfBoundsSystem
sout(x[1][2][0])=Re:ArrayIndexOutOfBoundsSystem
sout(x[1][1][1])=100
sout(x[2][1][0])=RE:ArrayIndexOutOfBoundsSystem

int []x ;
x={10,20,30};❌ //RE:illegal start expression
if you decleare multipule line we will get compli tiime error we can define only one line 

length VS length();
length:
        int[] x = new int[6];
        sout(x.length()); //CE: connot find symbol
                          symbol:method length();
                          location:class int[]

        sout(x.length); // 6
    
    length:is a final variable aplicable for aarays 
          but not for String Object
          length variable represent size of array

    String s = "Vivek";
    sout(s.length); //CE: connot find symbol 
    sout(s.length());  // 5

  length(); is a final method aplicable for String Objects but not for aarays length() method return number of charactrue prsent in the string 

String[] s= {"A","AA","bbb"};
sout(s.length)✅
sout(s.length());❌
sout(s[0].length);❌ CE: connot find symbol variable length
sout(s.[0].length());✅

int[][] x= new int[6][3];
sout(x.length) // 3;

we can create Anonymous as followes
new int[]{10,20,30,40};✅
new int[3]{10,20,30,40};❌
new int[][]{{10,20},{30,40,50}};✅

while creating Anonymous arrays we con't specified the size otherwise we will get compile time error

we can create multipuldimesional Anonymous array also-> new int[][]{{10,20},{30,40,50}};✅


bassed our requirement we can give the name for Anonymous array  then it is no longer Anonymous
int[] x = new int[]{10,20,30};

in the above example just to called some method an array but ofter complete we are not useing anymore hence for this one time requirement Anonymous array bset choice 

Array Element assigenment :
Case 1:
    int[] x = new int[5];
    x[0]=10;
    x[1]='a';
    byte b= 20;
    x[2]=b;
    short c =30;
    x[3]=s;
    x[4]=10L ; // CE: pericission loss 

  
byte -> short -> int -> long -> float -> double
        char  -> int -> long -> float -> double

    note->  in the above case of primitive arrays as array element we can provide any type which can be impleciticly prmoted to declared type


  Case 2 :
  example 1:
          Object[] a = new Object[10];
          a[0] = new Object();
          a[1] = new String("Vivek");
          a[2] = new Integer(10);

  example 2:
          Number[] n = new Number[10];
          n[0] = new Integer[10];
          n[1] = new double(10,5);
          n[2] = new String("vivek"); //CE: incompatiable types Found String;

example 3: 
          Runable[] r = new Runable[10];
          r[0] = new thread();
          r[1] = String("Vive");  //CE: incompatiable types Found String Require j.l:Runable; 
        
        for interface types array element its implimentations class object allowd 

  
Array type                 Allowd element types
primitive Array -> any types which can be impleciticly prmoted to declare types
Object types Array -> Either declare types or tis child class Object allowd
Abstract class type Array -> its child class Ojbect are allowd
Interface typed array -> its implimentations class Object are allowd


Array Veriable assigenment :
int [] x = {10,20,30,40}
char[] ch = {'a','b','c','d'};
int[] b =x;  //✅
int[] c = ch;  //❌ element level are not permoted 
              CE: incompatiable type found: char[] require int[];
           // char[] = [C
           // int[] = [I 

which are permotion will be performed automatically 
char    -> int✅
char [] -> int[]❌
int     -> double✅
int []  -> double[]❌
float   -> int ❌
float[] -> int[]❌
String  -> Object✅
String[] -> Object[]✅

but in case of Object types array child class typs array can be prmoted to parent class type array 

String[] A ={"a","b","c"};
Object[] a = A;✅

CASE 2:
      int[] a = {10,20,30,40,60};
      int[] b = {70,80};
      a = b;✅
      b = a;✅

 whenever we are assigen one array to another array inter element want be copy just reference variable will reassgined 
  
  int[][] a = new int[3][]
  a[0]  = new int[4][3];  //CE: incompatiable types found : int[][] require: int[];
  int[0] = 10; //CE: incompatiable types found :int 
  require int [];

  note -> whenever we are assigen one array to another the dimesion must be matched for example in the place one dimensinal int array we should provide one dimensinal array only
  if trying to provide any other dimesion then we well get compile time error 

note -> whenever we are assigen one array to another aaray both dimesion and types must be matched but sized are not require to match 
int a[0] = new int[2];

int [][] a =new int[4][3];  ->5
a[0] = new int[4];    ->1
a[1] = new int[2];      ->2
a = new int[3][2];        ->4

Q. total how many object create ?
ans. 12
Q. total how many object eligible for Gargbeg collection ans.8

 Types of variable

type of variable -:

bassed on type of values represent by a variable all variable divided into two types 
1. primitive variable > con be used primitive values 
  example ->
   int x =10
  
  reference variable can be used to refer object 
  Student s = new Student();

division 2->  bassed on position are declare and behaviour all variable divided into three types 
 1.Instace variable
 2. static variable
 3.Local variable

 1. Instace variable-> if the values a variable is varid form object to Ojbect such type variable are called Instace variable
 2. for every Ojbect seperat copy instance object will be created.
 3. instance variable should declear within the class directly but outside many method or block or constructore 
4.instance variable will be created at the time of creationg and destoryd  the scope instance excitly the scope of object
5. instance variable will be stored in the heap memory is the port of Ojbect
6.we con't access instance variable directly form static area but we can access by using Ojbect reference , but we access instance variable directly from instance area

 for instance variable jVM will always default values and we are not requirment to fper fomr explicitly
 or 
 Instance variables are fields declared within a class but outside any method. They are used to store unique data for each instance of the class. Unlike class variables (static variables), which are shared among all instances, instance variables have distinct values specific to each individual object.

instance variable also known as object level variable are attibutes

class Test{
  int x =10;
  public static void main(String[] args){
    Sout(x); ❌//CE: non-static variable x connot be reference form on static context
    Test t = new Test();
    sout(t.x); ✅
  }
  public void m1(){
    sout(x);
  }


}

class test{
  int x;
  double d;
  boolean b;
  String s;
  public static void main(String[] args){
    Test t1 = new Test();
    sout(t1.x); // 0
    sout((t1.d)); // 0
    sout(t1.b) ; //false;
    sout(t1.s); // null
  }
}
 

**Static variable ->
class Student{
  String name;
  int rollNo;
static String sName;
}

if ststic values of variable createing one copy and share all object;
1. if the values of a variable is not varid object ot Ojbect then it's not Recommended to declare variable as instance variable we have decleare such types variable at class level by using static modifire .

2. In the case of instance variable for every object seperat copy will be created but in the case of static variable a singal copy will be created at the class level and share bye every object of the class

3.static variable should be declare wihtin the class directly but outside any block or method or constructore 

4. static variable will be created at the time of class loading and destoryd at the time class unloading hence scope of static variable is excitly same as scope of dot class file 

Process:
Java Test <-
1.Start jVM
2.create & start main Thread
3.Locate Test class file
4.Load Test.class  //static variable is creation 
5.Excute main() methods
6. Unload Test class // static variable is destoryd
7.Terminate main Thread
8.Shut down jVM

static variable stored in Method are 

class Test{
  static int x =10;
  public static void main(String args[]){
    Test A = new Test();
    sout(t.x); ✅ // readbility dowon 
    sout(Test.x);✅ 
    sout(x);✅
  }
}

we can access static variable either by Ojbect reference or class name but Recommended to used class name 

within the same class it is not require to used to class name and we can access directly
class Test{
  static int x =10;
  public static void main(String args[]){
    Test A = new Test();
    sout(x);✅
 }

public class StaticVariable{
  static int x =10;
  public static void main(String[] args) {
    StaticVariable s = new StaticVariable();
    s.m1();
  }
  public void m1(){
    System.out.println(x);
  }
}


we can access static variable directly form both instance and static areas 

public class static2 {
  static int x;
  static double d ;
  static String s;
  public static void main(String[] args) {
    System.out.println(x); //0
    System.out.println(d); // 0.0
    System.out.println(s); // null
  }
}


for static variable jVM provide default values and we are not require to perform iniliaztion explicitly

static variable also known as class level variables or Fields 

class Test {
  static int x = 10;
  int y = 20;

  public static void main(String args[]){
    Test t = new Test();
    t.x=888;
    t.y=999;
    Test t2 = new Test();
    System.out.println(t.x +" " + t2.y); // 888 20
  }
}



**Local Variable  
  1. some times to meet temporary requirment of the progrmmer we can decleare variables inside a method or block or constructore such types of variable are called local variable or temporary variable or stack variable or automatic variables

  2. local variable will be stored inside stack memory
  3.local variable will be created while excuting the blcok in which declare it 
  4. onece block excution compelete automatically local variable will be destoryd hence the scope of local is blcok in which declare it 

  5. 
  public class LocalVariable{
    public static void main(String[] args) {
      int i=0; {
        for (int j=0; j<3; j++){
          i+=j;
        }
        System.out.println(i+" "+j);❌ // connot file symbol variable j 
      }
    }
  }

  for local variable jVM own to provide default values compersulry we should perform iniliaztion explicitly

  class test{
    public static void main(String args[]){
      int x =0;
      sout("hello");
    }
  }

  class Test{
    public static void main(String args[]){
      int x;
      sout(x);❌ // CE: x might be not have 
    }
  }



  before using that variable that is if we are not using then it not require to perform iniliaztion

  public class LocalVar2 {
    public static void main(String[] args) {
      int x;
      if(args.length>0){
        x=10;
      }
      System.out.println(x); ❌//CE:error: variable x might not have been initialized
    }
  }

  public class LocalVar2 {
    public static void main(String[] args) {
      int x;
      if(args.length>0){
        x=10;
      }else{
        x=20;
      }
      System.out.println(x);✅
    }
  }

  note: 
  1.it is not Recommended to perform iniliaztion for local variable inside logical blcoks becuase there is no garentee for the excution of these block always at run time 
  2.it is highily Recommended to perform iniliaztion for local variables at the time of declartion at least with default values
  3.

  class Test{
    int x =10;  public ,private,default,protect
  }

  the only applicable modifire for the local variable is final by mistake if trying to apply any other midifire then we will get compile time error 

  public class localAccesModifire {
    public static void main(String[] args) {
      public int a=10;❌ // illegal start of experssion
      private int x = 10;❌
      protected int b=10;❌
      static int c =10;❌
      transient int x=10;❌
      volatile int d=10;❌
      final int f =10;✅
    }
  }



  class Test{
    int x=10;
    static int  y=10;
    public static void main(String args[]){
      x 
    }
  }
  note: if we are not declare with any modifire then by default it is default but this rule is applicable only for instance and static variable but not for local variables 

  summary conculsion 
  1.for instance and static variable jVM will provide default values and we are not require perform iniliaztion explicitly but for local variable jvm want provide default values compersulry we should perform iniliaztion explicitly before using that variable
  2. instance and static variable can be access by multiple therad simulteniously and hence these are not thread safe but in the case of local variable for every thread seperat copy will created and hence local variable thread safe 

  **thead -> Thread safety in java is the process to make our program safe to use in multithreaded environment, there are different ways through which we can make our program thread safe. Synchronization is the easiest and most widely used tool for thread safety in java.

  type of variable               if thread safe ?
  1.instance variable       no
  2. stack variable          no
  3. local variable         yes 


  class test{
    int x =10; //  instance-primitive
    static String s = "Vivek"; // static-reference 
    public static void main(String args[]){
      int[] y = new int[3]; // local-reference
    }

  }

  note: every variable should be either instance or static or local 
  2. every variable in java should be either primitive or reference hence verisou possible combination of variable in java or  
  instance -> primitive , reference
  static  -> primitive , reference
  local  -> primitive , reference


  Uninilization Arrays

  public class unInilizationVar {
    int[]x;
    public static void main(String[] args) {
      unInilizationVar t = new unInilizationVar();
      System.out.println(t.x); // null;
      // System.out.println(t.x[0]); //Exception in thread "main" java.lang.NullPointerException: Cannot load from int array because "<local1>.x" is null
    }
  }


  public class unInilizationVar{
    int[] x = new int[3];
    public static void main(String args[]){
      unInilizationVar un = new unInilizationVar
      sout(un.x)// [I@823 (toString method)
      sout(un.x[0]);  //0
    }
  }

  2. static level
  1.static int x[]= x;
  sout(x); // null
  sout(x[0]) // RE: NullPointerException

  2. static int[]x = new int[3];
  sout(x) ; [I@23we;
  sout(x[0]); // 0


  3. local level 
  1. int[] x;
    sout(x); CE: variables x might not have iniliaztion
    sout(x[0]); CE: variables x might not have iniliaztion
  2. int x[] = new int [3] ;
    sout(x); // [@3dwe
    sout(x[0]);  // 0

    onec we create an array every element by default iniliaztion with default values irrpesctive of weather instance or static or local array

**var-arg methods (variable number of argument method) :-> sum(int... a)
  until 1.4 version we con't declare a method with variable number of argument if there is a change in number of argument compersulry we should go far new method it incrse length of code and reduced readbility then overcome this problem some people introduces ver-arg method in 1.5 version according to this we can declare a method which can variable  no of argument such type method are called ver-args method 
  
  we can declare ver-arg method as follows
  ex. m1(int... x); 
  we called this method by passing any number of int values including zero number 
  m1();
  m2(10);
  m2(10,20,30);
  m1(10,20,30,40,50,50... n);

  public class verArg {
  public static void m1(int... x){
    System.out.println("ver-arg method");
  }
  public static void main(String[] args) {
    m1();  //ver-arg method
    m1(10);   //ver-arg method
    m1(20,30,30,34);    //ver-arg method
  }
}

note : internaly ver-arg parameter convert into 1D hence wihtin ver-arg method we can diffreciate values by using index


public class verArg2 {
  public static void main(String[] args) {
    sum(10,20,30,40);// 60
    sum(10,20,0); // 30
  }
  public static void sum(int... x){
    int total =0;
    for(int a: x){
      total +=a;
    }
    System.out.println("the sum "+total); //60
  }
}


loophole->
which are follwing vaid declaration 
m1(int... x)✅
m1(int   ...x)✅
m1(int...x)✅
m1(int.   ..x)❌
m1(int x...)❌
m1(int  .x..)❌

m1(int x, int... y)✅
m1(Sting s, double ...x);✅
m1(double... x, Sting s); ❌

case3.if mix normal parameter with ver-arg parameter then ver-arg should be last parameter

m1(int... x, double... d);//❌
inside ver-arg we can take only one ver-arg parameter and we can't take more than one ver-arg parameter

class Test{
public static void m1(int... x){ //convert => m1(in[])
    sout("int...);
  }
public static void main(int[] x){//convert => m1(in[])
    sout("int[]");
  }
}

inside a class we con't  declare ver-arg and Corressponding 1D array both method  simulteniously otherwise we will compile time error 

class Test{
  public static void m1(int... x){
    sout("ver-arg method);
  }
  public static void m1(int x){
    sout("General method");
  }
  public static void main(String args[]){
    m1(); ver-arg
    m1(10,20); ver-arg
    m1(10); // General method ver-args least priority
  }
}

note : if old concept and new concept compare then win will be old concept old concept most priority

in General ver-arg method will get least priority if no other method matched then only ver-arg will get change it is excitly same as default case inside switch  

whenever 1D array prsent we can replace with ver-arg parameter
m1(int []x) => m1(int... x);
main(String arg[] ) => main(String... args);

Reverse:
m1(int... x)    ->m1(int[]x)
m1();             ❌
m1(10);           ❌
m1(10,20,30)        ❌
m1(new int[]{10,20});✅

wherever ver-arg parameter prsent we con't replace with 1D array
m1(int... x) => m1(int []x);❌

note:  convert 
m1(int... x ) => int[] x; 
m1(String... s) => String[] x;
m1(int[]... s) => int[][] x;

we can called this method by passing a Group of 1D int array and x will become 2D int array 

class Test{
public static void main(String args[]){
  int [] a = {10,20,30};
  int [] b= {40,50,60};
  m1(a,b);
  }
  public static void m1(int[]... x){
   for(int x1: x){
    sout(x1[0]) // 10,40;
   }
  }
}


Fundamentals part 13 || main() method:->

wheather class contain or not and main method declare according to requirment or not these things own to  check by compiler yet run time jvm responsbile thise things if jvm unaviable then we will get run time exception saying no such method error :main 



yet run time jvm such as the main method with follwing prototyre
public :to create calss Jvm from anywhere 
static: without existing Ojbect also Jvm have to case this methoed
main: main() method won't reutn anythings to Jvm
String: this is the name which i 
args : command line argument

above syntax very strick if we perforem any change then we will get runtime exception saying no such method error : main 


we can declare stirng array in acceptable form 
1.static public
2.main(String args[])
  main(String [] args)
3.insted args we can take any valid java indentifire
main(String[] vivek) 
4.we can replace string array with ver-args parameter
  main(String... args)

public class lect13mainFinal {
  static final synchronized  public void main(String... vivek){
    System.out.println("Vaild main method");//Vaild main method
  }
}

which of the follwing main method declaration valid
1.public static void main(String args)❌
2.public static void Main(String[] args)❌
3.public void main(String[] args)❌
4.public static int main(String args[])❌
5.final synchronized public void main(String args[])❌
6.final synchronized strictfp public static void main(String args[])✅
7.public static void main(String... args)✅


in which of above casese we will get compile time error 
=> we want get compile time error any where but except last tow cases in remian we will get run time exception saying no such method error main 

case 1: 
class Test{
  public static void main(String args[]){
    sout("String[]");
  }
  public static void main(int[] args){
    sout("int[]");
  }

}

overloading of the main method is possible but Jvm will always call string array argument main method only the othre overLoaded method we have to called excitly like normal method called 




case 2:
   inheritance concept aplicable for main method hence while excuting child class if child does't contain main method then parent class main method will be excuted 

  file name is -> Parent.java
class Parent{
  public static void main(String args[]){
    sout("Parent main");
  }
}
class Child extends Parent{

}

javac Parent  
 Parent.class , child.class 
 java parent ->output=> Parent main 
 java child -> output => Parent main 


Case 3:
  class Parent{
  public static void main(String args[]){
    sout("Parent main");
  }
 }
class Child extends Parent{
 public static void main(String args[]){
    sout("Child main");
  }
 }

javac Parent  
 Parent.class , child.class 
 java parent ->output=> Parent main 
 java child -> output => child main 

note=> it is method hinding but not Overrinding 
-> its seens Overrinding concept aplicable for main method but it is not Overrinding and it is method hinding 

*Note -> for main method inheritance and overloading concept are applicable but Overrinding concept is not applicable insted of Overrinding method hinding is applicable


class Test{

}

RE: error Main method is not found in class Test
public static void main(String args[])


RC:rror: Main method not found in class NoMainMethods, please define the main method as:
   public static void main(String[] args)
or a JavaFX application class must extend javafx.application.Application

public class NoMainMethods {

  static {
    System.out.println("static blcok ");
    System.exit(0); jvm shout down
  }
}
1.7 version above is most require main method 
even the class contain static blcok it won't to be excuted if the class does't constain main method

public class NoMainMethods {

  static {
    System.out.println("static blcok ");
  }
  public static void main(String[] args) {
    System.out.println("maint method");
  }
}
output?  static block
        main method 
  
1.7 version


Command Line Argument :
the argument which are passing form command prompt 
are called command line argument with these command line argument JVM will create an array and by passing array as argument JVm will called main method
example: Java Test A B C <-|
    args[0] = A
    args[1] = B
    args[2] = C

Q.what is using Command line argument ?
Command line arguments are a powerful way to pass parameters to a program when it is executed. They allow users to customize the behavior of the program without modifying its source code

Class Test{
  public static void main(String args[]){
    int n =  Integer.parseInt(args[0]);
    sout(the squre of "+ n * n);
  }
}

the main Ojbective command argument is we can customize behavior of the main method

case 1:

    class Test{
      public static void main(String args[]){
        for(int i=0; i<=args.length; i++){ //error ArrayIndexOutOfBoundsSystem (i<=args.length)
          sout(args[i]);
        } 
      }
    }

if we replace less then or equal to less then we want to get run time exception

Case 2:
class Test{
      public static void main(String args[]){
       
       String [] argh = {"x", "y", "z"};
       args = argh (**imp)
       for(String s : args){
        sout(s)
         }
      } 
    }
    input -> A B C <-|
    output -> x y Z
    input -> A B 
    output -> x y Z
    input -> null 
    output -> x y Z


Case 3:
class Test{
  public static void main(String args[]){
    sout(args[0] + args[1]);
  }
}
input-> 10 20
output->1020 becuase String[] types variable

within main method command arguments are aviable in String form 

class Test{
  public static void main(String args[]){
    sout(args[0]); 
  }
}

input-> "Note Book"
output-> Note Book

usuallys space itself is the seperater between command line argument if our command itself contain space then we have to inclose that command line argument wihtin double quote ("")


**Java Coding Standards 

whenever we are writing java code it is highily recommended to follow coding standard 

whenever we are writing any components its name should reflect the purpose of that components (functionality)

the main advantage this approach is readbility and maintaibility will be imporoved

class A{
  public int mq(int a, int b){
    return a+b;
  }
}
//Amerpet Standards
Package com.durgasoft.scjp;
public class Calculator {
  public static int add(int number1, int number2){
    return number1 + number2;
  }
}
Hi-tech city Standards

Coding standard for classes :>
usually class name of nouns should start with upparcase charactrue and if constain multiple words every inner words should start with upparcase character 
ex. String , StringBuffer , Account, Dog (noun)

Coding Standards for inteface :>
Runable ,Serialiable , Comparable 

usually interface name are adjective should start with upparcase character  and if it constain multiple words every inner words Should start with upparcase character 

Coding standard for Methods  :>
print() , sleep(), run(), eat(), start()  (varb)

usually method name are either verbs or verb noun combination should start with Lower Case alphabet symbol and if it constain with multiple words then Every inner words should start with upparcase character (Chamal case convension)
ex.print() , sleep(), run(), eat(), start()  (varb)
  getName(), setSalary(), setName();

Coding standard for Variable :>
 usually variable names are nouns should start with lower case alphabet symbol and if it constain multiple words then every inner wrods should start with upparcase character (Chamal case convension)
 ex. name , age ,salary , middleName.

Coding standard constent :>
MAX_VALUES, MAX_PRIORITY, NORM_PRIORITY, PI,

usually constent name are nouns should constain only upparcase character and if it constain multiple words then these words are seperated underscore symbol
ex.MAX_VALUES, MAX_PRIORITY, NORM_PRIORITY, PI,

Note:> usually we can declare constent with public static final modifire 

JavaBen Coding Standards :>  
public class StudentBean{
  private String name;
  public void setName(String name){
    this.name = name
  }
  public String getName(){
    return name;
  }
}

 A java bean is simple java class with private properties public getter and setter method 
 class name hence of bean not allowd from Sun MircoSystem

 Sytanx for setter method 
 1.it should be public method the return types should void 
 2. method name should be perfix set 
 3. it should take some argument that is it should not be not argument methods 
 4.it should public method the return should not void 
 5. method name should perfix with get 
 6. is should not take any argument

 *7. boolean perporties getter method name can be prefix with either get are is but recommended to use is
 public class lect13mainFinal {
  private boolean Empty;
  public boolean getEmpty(){
    return Empty;
  }
  public boolean isEmpty(){
    return Empty;
  }
 }

 Java releated JavaBean 
 Listeners-> 
 case 1. 
      public void addMyActionListener(MyActionListener l){}
      public void registerMyActionListener(MyActionListener l)


case 2. to unRegistrue Listener 
1.public void revmoveMyActionListener( MyActionListener l) ✅
2.public void unRegisterMyActionListener( MyActionListener l)❌
3.public revmoveMyActionListener (ActionListener l)❌
4.public void deleteMyActionListener(MyActionListener l)❌


----> **Operator and Assigenment 
topics-> most importatent 
Increment and Decrement Operator
Arithmetic Operator
String concatenation operator
Releational operator
instance of operator
Bitwise operator
short circuit operator
type cast operator
conditional operator
new operator
[] operator
operator precendence
Evaluation order of operands
new VS newInstance()
instanceof VS isInstance()
ClassNotFoundException Vs noClassDefFoundError 

1.Increment and Decrement Operator :>
  y=++x   // pre-Increment
  y=x++   // post-Increment
 Decrement 
  y=--x    // pre-Decrement
  y=x--   // post-Decrement

  exprsion, iniliaztion of x, y  , final values of x
  y=++x;  ->  10              -> 11    -> 11
  y=x++   -> 10               -> 10    ->11 

case 1:>
  int x = 10;
  int y  = ++x;
  sout(y) ; // 11


  int x = 10;
  int y  = ++10;//CE: unexpected type values variable require
  sout(y) ;

 we can apply Increment and Decrement operators 
 only for variables but not for constent values if we are trying to apply for constent values then we will get compile time error 

case 2:>
  int x  =10;
  int y = ++(++x);❌ //RE:unexpeted type req variable
  sout(y);

  Listing of Increment and Decrement operator is not allowd 

case 3:>
 final int x =10;
 x= 11;❌ CE: connot assing a values to final values x
  sout(x);

  final int x = 10;
x++;❌ //CE: connot assing a values to final values x
  sout(x);

for final variable we con't apply Increment and Decrement operators 

case 4:>
  int x = 10;
  x++;
  sout(x); //11

  char ch = 'a';
  ch++;
  sout(ch); // b 

  double d = 10.5;
  d++;
  sout(d); //11.5

  boolean b  = true;
  b++;❌ //CE:operator ++ connot is applied to boolean 
  sout(b); //error 

  we can apply every primitive types except boolean

  byte b =10;
  b = b+1;❌ //Type mismatch: cannot convert from int to byte
  sout(b); //error 

  byte b =10;
  b++;
  sout(b); //11

  different between b++ and b=b+1 

  byte a=10;
   byte b = 20;
   byte c = a+b;❌//Type mismatch: cannot convert from int to byte(possible loss fo precision)
    byte c =(byte) (a+b);✅
   System.out.println(c);

if apply any Arithmetic operator between two variable a & b operator the result types is always max of (int, type of a, type of b)

 byte b = 10;
 b++;
System.out.println(b);

but in the case of Increment and Decrement operator internal type casting automatically


------>   Arithmetic Operator (+,-,/,*,%)

if we apply any Arithmetic operator between variable a & b the result type is always max(int, type of a, type of b)

byte + byte = int 
byte + short = int
short + short = int
byte + long = long 
long + double = double
float + long = float 
char + char = int
char + double = double

byte -> short ->  int -> long ->  float ->  double
char ->  int -> long ->  float ->  double


in integeral Arithmetic (byte short int long ) there is no way to reprsent infinitive hence if infinitive is the result we will get Arithmetic exception in integeral Arithmetic 
ex.sout(10/0) ; RE: Arithmetic / by zero 

but in floating point Arithmetic within breacket flaot and double there is way to reprsent infinitive
for this Flaot and Double class contain the fowlling two constain hence even though result is infinitive we want to get any Arithmetic exception in flaoting point Arithmetic 
ex. sout(10/0.0); infinitive
sout(-10.0/0); -infinitive
sout(0/0); java.lang.ArithmeticException: / by zero
sout(0.0/0); NaN 
sout(-0.0/0); NaN 


ArithmeticException :>
it is runtime exception but not compile -time error 
it is possible only in integeral Arithmetic but not in floaint point Arithmetic

String concatenation operators(+)

------------->**String concatenation
the only overLoaded operator in  java is (+) some times it access Arithmetic ans some time it String concatenation Operator 

 String a ="Vivek";
  int b=10,c=20,d=30;
  System.out.println(a+b+c+d); //Vivek102030 //"Vivek+b+c+d
  System.out.println( b+c+a +d);//30Vivek30 //b+c+"vivek+d
  System.out.println( b+a+c+d);//10Vivek2030 //b+"vivek"+c+d 


if atlest one argument is stirng type then (+) operator acces concatenation operator and if both argument are number type then (+) operator access Arithmetic addtion operator

String a ="Vivek"
int b =10, c=20, d=30
1. a=b+c+d; ❌ // incompatiable type found int req String
2. a=a+b+c;✅
3. b=a+c+d;❌// incompatiable type found int req String
4. b=b+c+d;✅

Releational Operator (<,<=,>,>=)
sout(10<20) true
sout('a'<10) false 97
sout('a' >'A')  true 97 65 
sout(true >false ) CE:

we can apply for every primitive type except boolean 

we con't apply relational operator for ojbect types 
sout("Vivek123" > "vive"); CE: operator connot to be applid to J.s. String 

sout(10<20) true;
sout(10<20<30); The operator < is undefined for the argument type(s) boolean, int

distinct of relational operator is not allowd other wise we gill get compile time error 

Equlity operator (== ,!=)
sout(10 == 20) //false
sout('a'=='b') //false
sout('a'== 97.0) //true
sout(false == false ) true;

we can apply Equlity operator for every primitive type including boolean type also 

we can apply Equlity operator for ojbect types also 
for ojbect reference r1,r2
r1==r2 return true , if only if both reference pointing to the same object (reference comparesion or address comparesion)

Thread t1 = new Thread();
Thread t2 = new Thread();
Thread k3 = t1
sout(t1 == t2 )//false
sout(t1 == t3) //true


 Thread t = new Thread();
    Object o = new Object();
    String s = new String("Vivek");
    System.out.println(t==o);
    System.out.println(o == s);
    System.out.println(s==t);❌ error: incomparable types: String and Thread
    
    if apply Equlity operator then compulsary there should be relational between argument typs 
    (either child to parent or parent to child or same type ) otherwise we will get compile time error saying incompatible types java.String and java.long.Thread
    

different b/w == operators & .equals() method
== reference comparesion 
.equals()  content comparesion

String s1 = new String("vivek");
String s2  = new stirng("vivek");
sout(s1==s2) // false;
sout(s1.equal(s2));

in General we can used == operator for reference comparesion wihtin address comparesion and equal for 
constent comparesion

r==null // false
null == null  // true

String s = null
sout(s==null) // true

note:> for any object reference are double equal to null is always false 

String s = new String("durga");

** instanceOf operator :>
we can used instanceOf operator to check weather the given object is of purticular type or not 

Object o = l.get(o);
if(o instanceOf Student)
  Student s = (Student )o;
  //perforem student specific functionality
else if(o instanceOf Customer)
  Custore c (Customer )o 
  //perform Customer specific functionality


  r instanceOf X //r= Ojbect reference x=lclass interface  

  Thread -> Ojbect 
  thread -> Runable

  ex 
  1. Thread t = new Thread();
  sout(t instedof Thread); true
  sout(t instanceOf Object); true
  sout(t instanceOf Runable); 

  Thread t = new thead();
  sout(t instanceOf String ); CE: inconvertable types found java.long.thread require java.long.String 

  to used instanceOf operator compulsary there should some relation between argument types (either child to parent or parent to child or same type) we will get compile time error saying inconvertable types 


sout(null instanceOf X ) = false always
sout(null instanceOf Thread ) = false always
sout(null instanceOf Runable ) = false always


**Bitwise Operator(&,|,^)
& = AND = BOTH Argument ARE True
| => OR => At leat one argument is true
^ => X-OR => exclusive or if boath argument are different then it is true otherwise false
sout(true & false) ; //false
sout(true | false ); //true
sout(true ^ false ); //true

System.out.println(4&5);//4 
4 = 100, 5 = 101  , Calculator of Binary NO.
 100
&101
=100
 
System.out.println(4|5);//5
 100
|101
=101

System.out.println(4^5);  //1 boht diff ->true
 100
^101
=001

 we can apply these operator for intigeral types also 

integeral types->The integral types are byte , short , int , and long , whose values are 8-bit, 16-bit, 32-bit and 64-bit signed two's-complement integers, respectively, and char , whose values are 16-bit unsigned integers representing UTF-16 code units (§3.1).
 
 **Bitwise Compliment Operator (~) tild symbol
 sout(~true); //CE:only applicable integeral not boolean
 we can apply this operator only for integer types but not for boolean types 

 sout(~4) //-5  only integer 
 ~100
 =011
 note:>32 Compliment perform not perforem 
 the most significant bit acces sing bit 
 0 mins positive , 1 mins = negative no
 positive noumber will be represent directlly in memory where as negative noumber will be represent indirectly in two Compliment form 

 boolean Compliment Operator (!) 
 System.out.println(!4);only boolean

//bad operand type int for unary operator '!'

 we can apply this operator only for boolean types but not ingtigal types

**short-crcuit Operator(&&,||)
these are excitly same as betwise operator AND ,OR
except the following diffreces 


normal(&,!) :>
both argument check 
it is applicable for both boolean and integeral types 

short-crcuit(&&,||) :> 
it is most used in boolean types  
only first argument check if it is true than check second argument 
it is svae time 

1.both argument should evealuted always
1.second argument evealution is optional
2.reativily perfomence is low   
2.reativily perfomence is highily
3.applicable for both boolean and integeral
3.applicable for only boolean but not integeal 

note:> 
xx && yy -> y will be evealuted if only if x is true 
          that is if x is false then y want be Evaluated 
xx || yy -> y will be evealuted if only if x is false
            that is x is true than y want be Evaluated

int x = 10, y=15
if(++x <10 & ++y >15){
  x++;
}else{
  y++;
}
sout(x + " " + y);  //11 17

int x = 10, y=15
  if (++x < 10 && ++y > 15) {
      x++;
    } else {
      y++;
    }
    System.out.println(x+" "+y); // 11 16
  }

  int x = 10, y=15
  if (++x < 10 | ++y > 15) {
      x++;
    } else {
      y++;
    }
    System.out.println(x+" "+y); // 12 16

  int x = 10, y=15
  if (++x < 10 || ++y > 15) {
      x++;
    } else {
      y++;
    }
    System.out.println(x+" "+y); // 12 16
  
   int x=10;
   if(++x<10 && (x/0)>10){
    System.out.println("hello");
   }else{
    System.out.println("hii");
   }
  output -> hii

if we replace && with & then we will get runtime Exception saying division by zero 

**Type Cast Operator 
there are two types 
1.Implicit type casting
2.Explicit types 

int x='a'  
sout(x) //97  implicit

double d =10;
sout(d); //10.0  implicit [compile convert int to double automatically by implicit typecasting ]

note.
1.compiler
2.smaller->bigger values
3.widening or upcasting
4.no loss of information 


compiler is responsbile to perforem to implicit type casting
2.whenever we are assing smaller to bigger data types variable implicit type casting well be performed
3. it is also known as widening or upcasting 
4.there is no loss of information in this type casting 
5.the following are verisou possible conversion where implicit type casting will per performed
byte->short->int->long->float->double
chars->int->long->float->double

int x =130;
byte b = x; // CE: possible loss of precision found int require byte;
byte c = (byte)x; /-126,  Explicit

note:
1.programmer
2.Bigger->smaller
3.Narrowing 
4.Loss of pericission

1. progrmmer is responsbile to perforem explicit types casting 
2.whenever we are assing bigger data type values to smaller data types variable than explicit type casting is require
3.it is also known as Narrowing or down-casting
4.there may be chance of loss of information is this type-casting 

if move to 
**byte->short->int->long->float->double
left to right -> implicit type-casting
right to left -> explicit  type-casting


**Assigenment operator
there are three  types of assigenment operator

1.simple
  int x=10;
2.chaind 
  int a,b,c,d;
  a=b=c=d=20;
  sout(a+" "+b+" "+c+" "+d+);
3. compund 
  a+=20

 int a=b=c=d=20;❌//CE:connot find symbol symbol variable b location class test 

 we con't performed chaind assigenment directlly at the time of declaration
 int b,c,d;
 int a=b=c=d=20; ✅



sometimes assigenment operator mixed with some other operator such type of assigenment operator are called compound assigenment operator
:>compound
 int a =10;
 a+=20;
 sout(a); //30

the follwoing are all possible compund assigenment in java 
possible operator (11 items)
+=, -=, *=, /=, %=
&=, !=, ^=
>>=, >>>=, <<=, 

 byte b = 10;
  b=b+1; //CE:❌
    System.out.println(b);

 byte b = 10;
    b++;
    System.out.println(b);✅

byte b = 10;
b+=1;
System.out.println(b);✅

in the case of compound assigenment operator internal type casting performed automatically

int a,b,c,d;
   a=b=c=d=20;
    a+=b-=c*=d/=2;
    System.out.println(a+" "+b+" "+c+" "+d);
    //-160 -180 200 10

**conditional Operator(?,:)
a++,++a =>Unary operator
a+b => Binary operator

the only possible ternary operator in  java is conditional operator ->
int x = (c) ? b:d => ternary operator

we can performed distinct conditional operator also 
int x=(10>20) ? 30 :((40>50) ? 60 : 70) ;
sout(x) // 70 

** New Operator (new) ->
we can used new operator to create object 
ex. Test t = new Test();

Note:>
1.After creating ojbect constructure will excuted to performed iniliaztion of an ojbect hence constructure is not for creatation and it is for iniliaztion of an ojbect
2.in java we have only new keyword but not delete keyword because destraction useless responsbilitye of garbegcollector 

**[] Operator 
we can used this operator to declare and create arrays. 
ex. int[] x = new int[10];

Operator precendence :>
1.Unary operator
  [],x++,x--
  ++x, --x, ~,!
  new,<type>
2.Arithmetic Operator
  *,/,&
  +,-
3.Shift operator:
 >>,>>>,<<
4.comparesion operator
 <,<=,>,>=,instanceOf
5.Equlity operator
 ===, !=
6.Bitwise operator
 &
 ^
 |
7. short circuit operator
 && 
 ||
8.conditional Operator
?:
9.Assigenment operator
  =,+=,-=,*=1

Evaluation ordro of java operands
in java we have only operator precendence but not aprend precendence before applying any operator all operand will Evaluated form left to right
1+(2*3)/4+5*6
1+(6/4)+5*6
1+1+(5*6)
(1+1+30)
32

System.out.println(1+2*3/4+5*6); //32

1.new VS newInstance()
2.instanceOf VS isInstance()
3.ClassNotFoundException vs noClassDefFoundError

1.new VS newInstance():>
  Test t = new Test();
  Student s = new Student();


------>**Flow control 
flow control describe the order in which the statement will be excuted at run time 

1.Selection statement
  if-else
  switch
2.Iterative statement
 while()
 do-while
 for()
 for-each() 1.5
3.Transfer statement :>
 break
 constinoue
 return
 try-catch, finally
 assert 1.4



1.if(B){
  Action if  b is true;
}else{
 action if b is false 
}
the argument to the if statement should be boolean types by mistake if we are tryping to provied any other type then we will get compilt time error 

int x = 0;
if(x){ 
  sout("hello");
}else{
  sout("hi");
}

int x =10;
if(x=20){ //❌CE: incompatible type
  sout("hello");
}else{
  sout("hi");
}

int x =10;
if(x==20){
  sout("Hello");
}else{
  sout("hii"); 
}
//output :> hii

 boolean x = true;
    if(x = false){✅
      System.out.println("hello");
    }else{
      System.out.println("hii");
    }
    //output ->hii

    
     boolean x = false;
    if(x == false){ ✅
      System.out.println("hello");
    }else{
      System.out.println("hii");
    }

//output:hello
if(true); //✅

 if(true)
    int x=10; //❌ variable declaration not allowed 

 if(true)
    {int x=10;} //✅

***Switch()
if several options are aviable then it is not recommended to used nested if else because it reduced readbilites .
to handle this requirment we should switch statement

switch(x){
  case :1 
    action 1;
    break;
  case :2 
    action 2;
    break;
  case :3 
    action 3;
    break;
   default :
    defualt action;  
}

switch (argument)not allow ->boolean, long, float, double
allow ->byte char int ,byte, short, character, Integer, enum, String 

1. the allowd argument types for the switch statement are byte short char int util (1.4 version) but from(1.5 version ) Corressponding wrapper class and enum type also allow form (1.7 version ) String types also allow.


2. curly breacket are mendetaroy except switch every where curly breacket are optional.

3. both case and defualt are optional that is Empty switch statement is valid java syntax.
switch(X){

}//valid 

4.
  switch (10) { 
     
    System.out.println("yes");
    
    } 
    // 9 types error 

  inside switch every should be under some case are defualt that is independent statement not allow inside switch otherwise we will get compile time 
  error 

int x =10;
int y = 20;
switch(x){
  case 10:
          sout(10);
  case y :❌// constent experssion 
        sout(20);
        break; 
}
every case lebal should be compile time constent (that constent experssion )
  
if we declare y is final then we wnat get any compile time error 

 int x = 10;
    int y = 20;
    switch (x+1) {
      case 10:
        System.out.println(10);
      case 10+20+30: //✅
        System.out.println(20);
        break;
    }


     byte = 20;
    switch (x) {
      case 10:
        System.out.println(10);
      case 100: 
        System.out.println("100");
        break;
      case 1000: //❌
        System.out.println("1000"); // 
      
    }

     byte x= 20;
    switch (x+1) { ✅
      case 10:
        System.out.println(10);
      case 100: 
        System.out.println("100");
        break;
      case 1000: ✅
        System.out.println("1000"); // 
      
    }
every case should in the range of switch argument   otherwise we will get compile time error 

int x =10;
switch(x){
  case 97://❌Dulicate case 
    System.out.print(97);
    break
  case 98:
    System.out.print(98);
    break ;
     case 999:
    System.out.print(98);
    break ;
  case 'a':  
      System.out.print("a");

}

// ❌Dulicate case not allow 

case level summary
1.it should be constent exprsion
2.the shouldbe in the range of switch argument type
3.❌Dulicate case lavels are not allowd 

fall through inside switch

switch(x){
  case 0: 
        sout(0);
  case 1:
        sout(1);
        break;
  case 2:
        sout(2);
  defaul :
          sout("def");
}
input 0 = output 0,1
input 1 = output 1
input 2 = output 2, def
input 15= output def 

wihtin the switch if any caes is matched form the case on the word all statement will excuted until break or end of the switch this called for through inside switch.

the main advantage of fall though inside switch is we can define comman action for multiple case (code reusebility )

Scanner sc = new Scanner((System.in));
    int x = sc.nextInt();
      switch (x) {
        case 1:
        case 2:
        case 3:
        System.out.println("q-1-3");
          
          break;
        case 4:
        case 5:
        case 6:
        System.out.println("q-4-6");
       
          break;
      }

  
Default :>
wihtin the switch we can take default at most once.
2.defualt case will be excuted if an only there is no case matched within the switch we can writen defualt case anywhere but it is recommended to write as last case 

 Scanner sc =new Scanner(System.in);
   int x = sc.nextInt();
    switch ( x) {
   
      default:
      System.out.println("def");
        break;

        case 0:
        System.out.println("0");
        break;
        case 1:
        System.out.println("1");
        case 2:
        System.out.println("2");
    }
    //
    input 0, output = 0
    input 1, output = 1,2
    input 2, output = 2;
    input 12,output = def

  

Iterative statement
1.while()
2.for()
3.do-while()
4.for-each 


if we don't know noumber of Iteration in  advace then we should go for while loop 
while(rs.next){}
while(e.hasMoreElement){}
while(itr.hasnext()){}

while(condition ){ // should be boolean types  
   action 
}

note: the argument should be boolean type if we are trying to provide any other type then will get compile time error 

while(1){//❌Type mismatch: cannot convert from int to boolean
  sout("hello");
}



curly breacket are optional and without curly breacket we can take only one statement under while
which should not be declartive statement
1.which(true)
  sout("hello)✅

2.while(true)✅

3.while(true)
  int x = 10; ❌

4. while(true){
  int x = 10;✅
}


5. while(false) {//❌ Unreachable code
      System.out.println("hello");
   }
    System.out.println("hii");

6.while(true){//❌ Unreachable code
  sout("hello");
}
  sout("hi")

7. int a =10, b=20;
  while(a<b){
    sout("hello");//✅infinite 
  }
    sout("hii");

8.int a=10,b=20;
  while(a>b){
    sout("hello");
  }
    sout("hii");//✅once hii

9.  final int a = 10, b = 20;
    while (a < b) {
      System.out.println("hello");
 }
    System.out.println("hii"); //❌ Unreachable code


10.final int a =10,b=20;
    while (a>b) {
      System.out.println("hello");
      }
      System.out.println("hii"); //❌ Unreachable code

  
  
  note
  1. evey final variable will replace by the value yet compile time only
  final int a =10;
  int b =20;
  sout(a);
  sout(b);

  2. if every argument is final variable (compile time constent) then the operation should be performed yet compile time only 
  
    final int a = 10, b = 20;
    int c = 20;
    System.out.println(a + b); //30
    System.out.println(a + c);//30
    System.out.println(a<b); //ture;
    System.out.println(a<c); // true;


if we want to excute loop body at least once then we should go for do while
do{
  body
}which(b); // should be boolean types

 int b = 2;
    do // ✅
      System.out.println("hii");
    while (true); //✅

  do 
  int x =10; //❌
  which(true); //❌

  do //❌
  while(true);//❌

  curly breacket are optional and without curly breacket we can take only statement do and while which should not be declartive statement

 do while (true)  ✅
  System.out.println("hii");//✅ infinitive
  while (false) ; ✅

  looking carefull
   do
      while (true)
        System.out.println("hii");
    while (false);


  1. 
   do {
      System.out.println("hello");
    } while (true);
    System.out.println("hii");//CE:Unreachable

2. 
  do {
      System.out.println("hello");
    } while (false);
    System.out.println("hii");
    output// hello hii
3.
     int a =10,b=20;
  do{
    System.out.println("hello");
  }while(a<b);
  System.out.println("hii");
  output // hello  infinitive

4.  
    int a =10,b=20;
  do{
    System.out.println("hello");
  }while(a<b);
  System.out.println("hii");
  output // hello hii

5. final int a = 10, b = 20;
    do {
      System.out.println("hello");
    } while (a < b);
    System.out.println("hii");//❌ Unreachable

6.
     final int a = 10, b = 20;
    do {
      System.out.println("hello");
    } while (a > b);
    System.out.println("hii");
    //output = hello hii


***for Loop 
1. for is most commonly used loop in java 
2. if we know number of Iteration in advance then for loop is best choice 

for(iniliaztion section; condition ;Increment ){
  loop body 
}

note : curly breacket are optional and without curly breacket we can take only statement under for loop which should not be declartive statement 

for(int i=0; i<10; i++){
  sout(i);
}

for(int i=0; i<10; i++);

for(int i=0; i<10; i++)❌
  int x=10;  // ❌

this part will be excuted only once in loop cycle 
2. we can declare and iniliaztion local variable of for loop 
3.here we can declare any number of variable but should of the same type by mistake if we are trying different data type variable then we will get compile time error 

int i=0,j=0;
int i=0, String s ="vivek";❌
int i=0, int j=0; ;❌

 int i = 0;
    for (System.out.println("hi"); i < 10; i++) {✅
      System.out.println(i);
    }

in the iniliaztion section we can take any valid java statement including sout()

 int i = 0;
    for (System.out.println("hi"); true; i++) {
      System.out.println(i);
    }

here we can take any valid java expression but should be of the type boolean

this part is optional if are nat taking anythings then compile always place true

 int i = 0;
    for (System.out.println("hello"); i < 3; System.out.println("hii")) {
    i++;
    }
    // 
    hello
    hii
    hii
    hii

    in the Increment or decriment section any valid java statement including sout("ii");
  
  for(;;);
  
  for(;;){
    sout("hello");
  }
  all three part for loop are indipendent of each other and optional 

for(int i=0; true; i++){
  sout("hello");
}
sout("hii");❌ Unreachable

for(int i=0; false; i++){ //❌ Unreachable
  sout("hello");
}
sout("hii");

int a =10, b =20;
for(int i=0; a<b; i++){ 
  sout("hello");//✅ infinitive
}
sout("hii");

final int a=10,20;
for(int i=0; a<b; i++){ //❌ Unreachable
  sout("hello");
}
sout("hii");


 final int a = 10, b = 20;
    for (int i = 0; a > b; i++) { // ❌ Unreachable
      System.out.println("hello");
    }
    System.out.println("hii");


for-each loop(enhanced for loop) //
1. introduces 1.5 version
2. it special desigend look retrive element of array 
and collection
example 1.
to print 1D aaray 
int x ={1,2,3,4}
for(int i=0; i<arr.length; i++){
  sout(x[i]);
}

for-each
int x ={1,2,3,4}
for (int x1 : x){ 
  sout(x1);
}

example 2.
to print of 2D array 
int [][]x = {{10,20 30},{40,50,60}};
for(int i=0; i<x.length ; i++){
  for(int j=0; j<x.length ; j++){
    sout(x[i][j]);
  }
}

 int[][] x ={{1,2,3,},{4,5,6,}};
  for(int[] x1: x){
    for(int x2 : x1){
      System.out.print(x2+" ");
    }
    System.out.println();
  }

 int[][][] x = { {{ 1, 2, 3 }, { 4, 5, 6 },{7,8,9} }};
    for (int[][] x1 : x) {
      for (int[] x2 : x1) {
        for(int x3 : x2){
          System.out.print(x3+" ");
        }
        System.out.println();
      }
      System.out.println();
    }



    for(int x:10){// ❌ 
    System.out.println("hii");
   }

note: for-each is best choice to retrive element of array and collection but its limitation is it is applicable only for aaray and collection and it is nat a General purpose loop 


***Iterable(I)
target -> Array /collection , Iterable Object
for(eachItem x: target ){

}

1.the target element in for-each should be Iterable object 
2.than object said to Iterable if only if Corressponding class class impliment java.long.IterableInterface 
3. introduces 1.5 it contains only on method Iterator 
public iterator iterrator()
4. Array releated class and collection implimented class already impliment Iterable interface being a programmer we are not require to do any things just we should awre the poing about Iterable 


diffreces between Iterator and Iterable
Iterator(I):> this is releated to collection
Iterable(i):> it si releated to for-each loop

Iterator:> we can use to retrive the element of collection one by one 
Iterable:> the target element in for-each loop should be Iterable


Iterator:>java.util.package
Iterable:> java.lang package

  Method 
Iterator:>1. i.hasNext()
          2. i.next()
          3. remove()
Iterable:> iterator()

  
  ***Transfer statement
1.break
2.constinoue

break:> we can used break statement in the following palceces
1.inside switch : stop fall through
  int x =0;
  switch(x){
    case 0:
      System.out.println(0);
    case 1:
      System.out.println(1);
      break;
    case 2:
      System.out.println(2);
    default :
      System.out.println ("Defalut");
       
  }
  output-0,1

2. inside loops
  to break loop excution bassed on some condition 
  for(int i=0; i<10; i++){
    if(i==5){
      break;
    }
    sout(i);
  }
  output: 0,1,2,3,4

3. Inside labeld blcoks:to break blcok excution bassed on some condition
 class Test{
  public static void main(String args[]){
    int x= 10;
    l:{
      sout("begin");
      if(x==10){
        break l;
      }
      sout("end");
    }
    sout("hello");  
  }
 }
 output->begin , hello
   
 int x =10;
  if(x==10) 
  break;//❌ error: break outside switch or loop
  System.out.println("hello");


**Continue
we can used continue inside loop to skip current iteration and continue for next Iteration 
    for (int i = 0; i < 10; i++) {
      if (i % 2 == 0) {
        continue; // never used outside loop 

      }
      System.out.println(i);
    }



Labeled Break & continue 
La1:
for(){
  la2:
  for(){
    for(){
      break la2;
      break ;
    }
  }
}
we can used labeld break and continue to break and continue a perticullar loop in nested loop 




-------------------------------------------------------------------------------------------------------
Declaration & Access Modifire
1.Java Soucre file structure
2.class Level modifire
3.Member level modifire
4.Interface


1.Java Soucre file structure:>
  a java program can constain any noumber of class but at most one can be declare as public if there is public than name of the program and name of the public class must be matched otherwise will get compile time error 
class A{}
public class B{}  // file name is B.java
class C{}
 class D{} 

if there is no public class then we can used any name and there is no ristriction 
class A{}
class b{}
class C{}
class D{}

case 2:
 if class B is public then name of the program should be B.java otherwise we will get compile tiem error saying class b is public should be declared in name with B.java 
public class B{}  // file name is B.java


case 3 :
if class B and C declare as public and name of the program is B.java then we will get compile time error saying class c is public should declare in a file named c.java 



 class manyClass {
  public static void main(String[] args) {
    System.out.println("A class");
  }
}

class B{
  public static void main(String[] args) {
    System.out.println("Class B");
  }
}
class C{
  public static void main(String[] args) {
    System.out.println("C class");
  }
}
class D{

}//❌Main method not found in class D, please define the main method as:
   public static void main(String[] args)

file name is: vivek.java 
             javac vivek.java //compile 
             4 file class file create 
class A = java A 
class B = java B 
class C = java c  
class D = //RE: Main method not found in class D, please define the main method as:
   public static void main(String[] args)

Conculusion :> whenever we are compile a java programme for every class prsent in program a seperat .class file will be genereted 

2. we can compile a java program (java source file ) but we can run a java a.class file 

whenever we are excuting a java class the Corressponding class main method will be excuted 

if class does't conatin main method then we will get run time exception RE: main method not found in class 

if the Corressponding that class file not aviable then we will get runtime exception saying no def found error.

 it is not recommended to declare multiple classes in singale scource file it is highily recommended to declare only one class per scource file and name of the program we have to keep same as class name 
 the main advantage of this approach is readbilites and maintaibility of the code will be imporoved 

class Test{
  public static void main(String args[]){
    java.util.ArrayList L = new java.util.ArrayList();

  }
}  

or 

 

import statement 
we can solve this problme by using fully qualified name -> java.util.ArrayList L = new java.util.ArrayList();

fully qualified (java.util.ArrayList)
the problem with full qualified name every time is it incrse the length of the code and reduced readbilites
we can solve this problem by using import statement 
whenever we are writing import statement it is not require full qualified name we can used short name directlly hence import statement acces typing shortcut .

import java.util.ArrayList;
class Test{
  public static void main(String args[]){
    ArrayList L = new ArrayList();
    
  }
} 


what is purpose import statement ? 
there are two types of import statement 
1.explicit class import  import java.java.Scanner;
2.implicit class import  import java.util.*;
 
1.explicit class import :> 
ex. import java.util.ArrayList; 
->it is highly recommended explicit class import becasue it imporoved readbilites or the code 
->best suitable for hi-tech city where readbilites is importaten 


2.implicit class import -> import java.util.*;
  not recommended to use because it readuce readbilites of the code 
-> best suitable for Amirpad where typing is import  
  is importaten

case 2 :
  which of the following import statement meaning full 
  import java.util.ArrayList;✅
  import java.util.ArrayList.*;❌
  import java.util.*;✅
  import java.util; ❌

case 3:
  consider the following code
class my Object extendsjava.rmiUnicastedRemotOjbec{}

point: the code compile fine even though we are not writen import statement
because we used fully qualified name

Note :
 whenever we are fully qualified name it is not require to right import statement similarily 
 it is not require to used fully qualified name 

 import java.util.*;
import java.sql.*;



public class cmd {
  public static void main(String[] args)  {
    Date d = new Date();
  }
}
cmd.java:6: error: reference to Date is ambiguous
    Date d = new Date();
                 ^
  both class java.sql.Date in java.sql and class java.util.Date in java.util 1 match 2 errors

  note: even the case of the List we may get same ambiguous problem because it is aviable in both util and awt package  


while resolveing compiler will give precedence in the following 
1.Explicit class import 
2.Class present in CWD(Current working dirctory) (Default package )
3.Implicit class import 

whenever we are importing a java package all cleasses and interface present in the package by defaul aviable but not subpackage classes if we subpackage class comparsalry we should wirte import statement unitl sabpackage level 
ex. 
java -> util->regex ->Pattern 

to used patter in our program which import statement is require 
1. import java.*;
2. import java.util.*;
3. import java.util.regex.*;✅
4 no import require


all class and Interface prsent the following package are by default aviable to every java programme hence we are not require  to right import statement .
1. java.long package.
2. defualt package(current working dirctory).

import statement is toatly compile releated concept 
if more number of import then more will be the compil time but there is no affect on excution time (run time).

case 9 :
different between c longuage #include<stdio.h>
and java import statement .
in the case of c longuage #include all input output header at the loaded beging only (at translation time ) hence it is static include .

but in the case of java import statement no dot class file will be loaded at the beging whenever we are using a purticular class then only Corressponding
dot class file will be loaded this is like dynamic include this is consider as dynamic include  or load on dimand or load on fly 

Note: 1.5 version new featrues 
1.for-each loop
2. ver-arg method
3. autoboxing 
4.Generic
5.Co-verient return types
6.Queue
7.Annotations
8.enum 
9.Static import


**Static import :> introduces in (1.5 version)
according Sun uses of static import reduced length of the code and improvd readbilites but according word wide programming export (like us) uses of static import create confusion and reduced readbilites
hence if there is no specific requirment then it is not recommended to used static import 



note : usually we can acces static member by using class name but whenever we are writing static import 
we can access static members directelly without class name 
:>without staic import 
public class cmd {
  public static void main(String[] args)  {
    System.out.println(Math.max(45,45)); //45
    System.out.println(Math.sqrt(4));  //2.0
    System.out.println(Math.random()); //0.208982867
  }
}

:> with static 
import static java.lang.Math.*;
public class cmd {
  public static void main(String[] args)  {
    System.out.println(max(45,45)); //45
    System.out.println(sqrt(4)); //2.0
    System.out.println(random()); // 0.32423324223
  }
}


class Test{
  static String s="Vivek";
}
public class Test1{
  Test.s.length();
}

Explain about:> System.out.println();
Test->Test is a class name
s-> s is a static variable present in Test clas of the type java.lang.String 
length()-> length() is a method present in String class

class System{
  static PrintStream out;
}
System.out.println();
System->System is a class prsent in java.lang package
out->out is a static variable present in System class of the types PrintStream 
println()->println() is method prsent in PrintStream class 

import static java.lang.System.*;
class Test{
  public satatic void main (String args[]){
    out.println("Vive");
  }
}

out is a static variable present System in class hence we can access by using class name System but whenever we are useing writing static import it is not require to use class name and we can acces out directlly 

import static java.lang.Integer.*;
import static java.lang.Byte.*;

public class cmd {
  
  public static void main(String[] args) {
  
   System.out.println(MAX_VALUE);//CE:The field MAX_VALUE is ambiguous

  }
}

 import static java.lang.Integer.MAX_VALUE;
import static java.lang.Byte.*;

public class cmd {
  static int MAX_VALUE = 999;
  public static void main(String[] args) {
  
   System.out.println(MAX_VALUE);
  }
}
 output -> 999

 import static java.lang.Integer.MAX_VALUE;
import static java.lang.Byte.*;

public class cmd {
  // static int MAX_VALUE = 999;
  public static void main(String[] args) {
  
   System.out.println(MAX_VALUE);
  }
}
output-> 2147483647


// import static java.lang.Integer.MAX_VALUE;
import static java.lang.Byte.*;

public class cmd {
  // static int MAX_VALUE = 999;
  public static void main(String[] args) {
  
   System.out.println(MAX_VALUE);
  }
}   
output->127




while resolveing static member compiler will always consider the precedence in follwing order
note:  priority 
1.current class Static member
2.explicit static import
3.Implicit static import


    import static java.lang.Integer.MAX_VALUE; //2️⃣
    import static java.lang.Byte.*;//3️⃣

    public class cmd {
      static int MAX_VALUE = 999; //1️⃣
      public static void main(String[] args) {
      
      System.out.println(MAX_VALUE);
      }
    }

    1️⃣->if we comment this line then explicit import consider and hence integer class MAX_VALUE will be consider in this case output is 2147483647
    
    if we comment both line 1️⃣2️⃣ then implicit static import will be consider in this case output is 127[byte class max values ]


    normal import 
    1.Explicit import
      Syntax :
      import packagename.classname;
        ex:import java.util.ArrayList;

    2.implicit import 
      Syntax:
        import Packagename.*;
        ex: import java.util.*;

    
    static import 
    1.explicit static import:
        syntax:
        import static packagename.classname.staticmember;
        ex: import static java.lang.math.sqrt;
        import static java.lang.System.out;
    
    2.Implicit static import
      syntax:
      import static Packagename.classname.*;
      import staic java.lang.System.*;


which of the follwoing import statement are valid 
1.import java.lang.Math.*;❌
2.import static java.lang.Math.*;✅
3.import java.lang.Math.squrt;❌
4.import static java.lang.Math.sqrt();❌
5.import java.lang.Math.sqrt.*;❌
6.import static java.lang.Math.sqrt;✅
7.import java.lang;❌
8.imprt static java.lang;❌
9.import java.lang.*;✅
10.import static java.lang.*;❌

two package contains a class or interface with same name is vary rear and hence ambiguous problem is also very rear in normal import 

but two class are inteface contains a Veriable or method same name very common and hence ambiguous problem also very common problem in static import 

used of static import reducesd the readbilites and create confusion and hence if there is no specific requirement then it not recommended to used static import 

diffreces between normal and static import 
we can used normal import ,import classes and interface of a purticular package
->whenever we are writing normal import it is not require to used fully qualified name and we can used short name directly
->we can used static import to import static member of a purticular class or interface 
-> whenever we are writing static imprt it is not require to used class name to access static members 
and we can access directlly 


------------** Packages 
->it is encapsulation maschisom A group related claess and inteface into a singal Unit , which is nothing but Package
ex.
1. All classes and interface which are require for database operation are grouped into singal package which is nothing but java.sql package 
2. All class and inteface which are usefull for file io operation or grouped into seperat package which is nothing but java.io package

main purpose
1. to resolve nameing confilicts (that is unique identifactin of our conpnent)
2. modularity
3.imporoved maintaibility of application
4.it Security provides Security for our content 

there is one universally accpet nameing convension for package that is to used internet domain name in reverse 
com.icicbacnk.loan.housing.account 
com.icicbacnk ->client internet domain name is reverse
loan ->module name
houseing -> submodule name 
account -> class name 
 
 package com.durgaSort.scjp;
 public class Test{
  public static void main(String args[]){
    sout("pkg demo");
  }
 }
 1.javac Test.java 
    genereted dot class file will be current working dirctory in the test.class 
2. javac -d . Test.java
 (-d) destination to place genereted got class file 
 (.) dot mins current working dirctory

    genereted dot class file will be place in Corressponding package structure 

1. if Corressponding package structure not already aviable then this(javac -d . Test.java) command itself will create Corressponding package structure 

2.as destination insted of dot we can take any valid dirctory name 
 ex. javac -d F: test.java ;

3. if the specified dirctory not aviable then we will get compli time error 
javac -d Z: Test.java then we will get compil time saying dirctory not fund z: 


in any java source file there can be at most one package statement that is more then one statement is not allowd otherwise we will get compile time error 

package com1;
package com2;

public class cmd {
  
  public static void main(String[] args) {
    // Your code here
  }
}
// error: class, interface, enum, or record expected
package com2;

Consulusion 1:
  what is defferent between packge and import
  ->Using package, you can create a group of related classes, whereas import allows you to use classes from other packages.


import java.util.*;
package com1;

public class cmd {
  
  public static void main(String[] args) {
    // Your code here
  }
}
//cmd.java:2: error: class, interface, enum, or record expected
package com1;

in any java program the first non statement should be packge statement (if it aviable) otherwise we will get complie time error 

valid java Soucre file structure
1.packge statement;  //atmost one
2.import statement;  // any number 
3.class/interface/enum declartion // any number

order follwing as it is sequence

Note : an empty Soucre file is valid java program hence the following are valid java Soucre file 


1.  Test.java       // file name assume empty file 

2. package pack1;  
  Test.java

3. import java.util.*;
    Test.java

4. package pack1;
  import java.util.*;
  Test.java

5. class Test{

  }
  Test.java 


**Class Level modifire
whenever we are writing our own classes we have to provide some information about our class to the JVM 
like 
1. weather this class can be accessable form any wehere or not
2. weather child class creation is possible or not
3. weather object create is possible or not 

we can specific this information by using appropriate modifire 

12 modifire name 
public, private, Defalut, protected, 
final, abstarct, static, synchronized
native, strictfp, transient, volatile

the only applicable modifire for top level classes are 
public 
Default
final
abstarct
strictfp

but for inner classes the applicable modifire are 
are :
public 
Default
final
abstarct
strictfp
static 
private 
protected


private class cmd {
  // static int MAX_VALUE = 999;
  public static void main(String[] args) {
    // Your code here
  }
}
//cmd.java:2: error: modifier private not allowed here
private class cmd 
        ^
1 error


Access specifire VS access Modifire
public 
private
protected
Default
consider as specifire except these remains consider as modifire
but this rule is applicable only for old language like c++ 
but not in java 
in java all are consider as modifire only  there is no word like specifire 
private class test modifire not allow here
package pack1;

private class cmd {
  // static int MAX_VALUE = 999;
  public static void main(String[] args) {

  }
}

class leve ->public defualt final static abstarct

1.public classes ->
  if a class decleare as public than we can access that class form anywhere.

package pack1;
public class A {
  public void m1(){
    System.out.println("Hii");
  }
}
import pack1.A;

public class B {
  public static void main(String[] args) {
    A c = new A();
    c.m1();
  }
}

project-root/
├── pack1/
│   └── cmd.java
└── pubB.java


if class A is not pubilc then while compiling B class we will get compile time error 

2. Default classes -:>
 if class declare as default then we can access that class only within the currect packge that is form outside packge we cant access 
 hence default access also known as packge level access 
 

 Final modifire -> final is modifier applicable for classess method and variables 
 Final method ->
 
    whatever method parent have by defualt aviable to the child through inheritance
    if the child not satisfied with parent method implimentations 
    then child is allow to refien that method basses on its requirment this process is called Overrinding
if the parent class method as final then we con't override that method in the child cleass becasue its implimentations is final 

class P {
  public void prop() {
    System.out.println("Gold");
  }

  public final void monay() {
    System.out.println("money");
  }
}


class C extends P{
  public void monay(){//❌ connot overrdie fianl method
    System.out.println("you can marry now ");
  }
}



public class cmd{
  public static void main(String[] args) {
    C child = new C();
    child.prop();
    child.monay();
    child.marry();
  }
}


-> final class :>
  If a class is declared as final, it cannot be extended, meaning no subclasses can be created from it. In other words, inheritance is not possible for final classes.

final class P{

}
class C extends P{ //❌ we cannot inherit from  final class 

}


**Note:-> 
    every method present inside final class is always final by default but every variable prsent inside final need not be fianl 
  ex.
  final class p{
    static int x =10;
    public static void main(String args[]){
      x=999;//✅
      sout(x);
    }
  }

Note:>
The main advantage of using the final keyword is that it enhances security and allows for unique implementations. However, the primary disadvantage is that it prevents key benefits of OOP: inheritance (due to final classes) and polymorphism (due to final methods). Therefore, if there is no specific requirement, it is not recommended to use the final keyword.


**Abstract Modifire :>
1. abstarct is the modifier aplicable for classes and method but not for variable 

what is abstarct method ->
An abstract method is a method that is declared with the abstract modifier but does not have an implementation. This means that while the method is declared, its implementation is left to be provided by subclasses. Abstract methods are intended to be overridden by subclasses that extend the abstract class.

The declaration of an abstract method ends with a semicolon (;), indicating that there is no implementation in the abstract class.
An abstract method cannot have a body (implementation) in the class where it is declared.

// Correct: Abstract method declaration
public abstract void m1();

// Incorrect: Abstract method with a body is not allowed
public abstract void m1() {
    // Implementation not allowed
}


child class responsbile to provide implimentations for parent class abstract method 

abstract class Vechical{
  abstract public int getNoOFwheel();

}

class Bus extends Vechical{
  public int getNoOFwheel(){
    return 7;//(6+1) stefiniy
  }
}
class Auto extends Vechical {
  public int getNoOFwheel(){
    return 3;
  }
}

public class cmd{
  public static void main(String[] args) {
 Auto auto = new Auto();
 System.out.println(auto.getNoOFwheel());
 Bus bus = new Bus();
 System.out.println(bus.getNoOFwheel());
  }
}

by declearing abstarct method in the parent we can provide guidelines to the child classes such that which method compulsary 
child has to impliment